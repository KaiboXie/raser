import math
import ROOT
import numpy as np
from raser.geometry import R3dDetector

class TCTTracks():
    """
    Description:
        Transfer Carrier Distribution from Laser Coordinate System 
        to Detector Coordinate System
    Parameters:
    ---------
    my_d : R3dDetector
        the Detector
    laser : dict
        the Parameter List of Your Laser
    x_rel,y_rel,z_rel:
        the Normalized Coordinate for Laser Focus 
        in Detector Coordinate System
    @Modify:
    ---------
        2021/09/13
    """
    def __init__(self,my_d,laser):
        #technique used
        self.tech=laser["tech"]
        self.direction=laser["direction"]
        #material parameters to certain wavelength of the beam
        self.refractionIndex=laser["refractionIndex"]
        if self.tech == "SPA":
            self.alpha=laser["alpha"]
        if self.tech == "TPA":
            self.beta_2=laser["beta_2"]
        #laser parameters
        self.wavelength=laser["wavelength"]*1e-3 #um
        self.tau=laser["tau"]
        self.power=laser["power"]
        self.widthBeamWaist=laser["widthBeamWaist"]#um
        if "l_Reyleigh" not in laser:
            self.l_Rayleigh = np.pi*self.widthBeamWaist**2*self.refractionIndex/self.wavelength
        else:
            self.l_Rayleigh = laser["l_Rayleigh"]#um
        #the size of the detector
        self.lx=my_d.l_x#um
        self.ly=my_d.l_y
        self.lz=my_d.l_z
        #relative and absolute position of the focus
        self.fx_rel=laser["fx_rel"]
        self.fy_rel=laser["fy_rel"]
        self.fz_rel=laser["fz_rel"]
        self.fx_abs=self.fx_rel*self.lx
        self.fy_abs=self.fy_rel*self.ly
        self.fz_abs=self.fz_rel*self.lz
        #accuracy parameters
        self.r_step=laser["r_step"]#um
        self.h_step=laser["h_step"]#um
        self.t_step=laser["t_step"]#s
        self.min_carrier=laser["min_carrier"]
        
        self.mesh_definition(my_d)

    def mesh_definition(self,my_d):
        if self.tech == "SPA":
            self.h_char=max(my_d.l_x,my_d.l_y,my_d.l_z)
            self.r_char=min(my_d.l_x,my_d.l_y,my_d.l_z)

            self.change_coordinate()
            if self.fx_abs < 0.5 * self.x_char:
                self.x_min = 0
                self.x_max = self.x_char
            elif self.fx_abs > my_d.l_x - 0.5 * self.x_char:
                self.x_min = my_d.l_x - self.x_char
                self.x_max = my_d.l_x
            else :
                self.x_min = self.fx_abs - 0.5 * self.x_char
                self.x_max = self.fx_abs + 0.5 * self.x_char

            if self.fy_abs < 0.5 * self.y_char:
                self.y_min = 0
                self.y_max = self.y_char
            elif self.fy_abs > my_d.l_y - 0.5 * self.y_char:
                self.y_min = my_d.l_y - self.y_char
                self.y_max = my_d.l_y
            else :
                self.y_min = self.fy_abs - 0.5 * self.y_char
                self.y_max = self.fy_abs + 0.5 * self.y_char

            if self.fz_abs < 0.5 * self.z_char:
                self.z_min = 0
                self.z_max = self.z_char
            elif self.fz_abs > my_d.l_z - 0.5 * self.z_char:
                self.z_min = my_d.l_z - self.z_char
                self.z_max = my_d.l_z
            else :
                self.z_min = self.fz_abs - 0.5 * self.z_char
                self.z_max = self.fz_abs + 0.5 * self.z_char

        elif self.tech == "TPA":
            self.h_char=self.l_Rayleigh
            self.r_char=self.widthBeamWaist

            self.change_coordinate()
            self.x_min,self.x_max=max(0,self.fx_abs-2*self.x_char),min(self.lx,self.fx_abs+2*self.x_char)
            self.y_min,self.y_max=max(0,self.fy_abs-2*self.y_char),min(self.ly,self.fy_abs+2*self.y_char)
            self.z_min,self.z_max=max(0,self.fz_abs-2*self.z_char),min(self.lz,self.fz_abs+2*self.z_char)

        self.t_min,self.t_max=1e-9-2*self.tau,1e-9+2*self.tau
        
        xArray = np.linspace(self.x_min,self.x_max,int((self.x_max-self.x_min)/self.x_step))
        yArray = np.linspace(self.y_min,self.y_max,int((self.y_max-self.y_min)/self.y_step))
        zArray = np.linspace(self.z_min,self.z_max,int((self.z_max-self.z_min)/self.z_step))
        tArray = np.linspace(self.t_min,self.t_max,int((self.t_max-self.t_min)/self.t_step))

        Y,X,Z,T=np.meshgrid(yArray,xArray,zArray,tArray) #Feature of numpy.meshgrid
        self.projGrid=self._getCarrierDensity(X,Y,Z,T)\
            *self.x_step*self.y_step*self.z_step*1e-18*self.t_step
        self.original_track_position = list(np.transpose(np.array([
            list(np.ravel(X)),\
            list(np.ravel(Y)),\
            list(np.ravel(Z)),\
            list(np.ravel(T))])))
        self.original_ionized_pairs = list(np.ravel(self.projGrid))
        self.track_position = []
        self.ionized_pairs = []
        for i in range(len(self.original_ionized_pairs)):
            if self.original_ionized_pairs[i]>=self.min_carrier:
                self.ionized_pairs.append(self.original_ionized_pairs[i])
                self.track_position.append(self.original_track_position[i])

    def change_coordinate(self):
        #from cylindral coordinate (axis parallel with the beam, origin at focus)
        #to rectilinear coordinate inside the detector
        if self.direction in ("top","bottom"):
            self.z_step=self.h_step
            self.z_char=self.h_char
            self.x_step=self.y_step=self.r_step
            self.x_char=self.y_char=self.r_char
            if self.direction == "top":
                absorb_depth=self.lz*self.fz_rel
                def _getCarrierDensity(x,y,z,t):
                    return self.getCarrierDensity(z-self.fz_abs,absorb_depth,(x-self.fx_abs)**2+(y-self.fy_abs)**2,t-1e-9)
                self._getCarrierDensity=_getCarrierDensity
            if self.direction == "bottom":
                absorb_depth=self.lz*(1-self.fz_rel)
                def _getCarrierDensity(x,y,z,t):
                    return self.getCarrierDensity(self.lz-z+self.fz_abs,absorb_depth,(x-self.fx_abs)**2+(y-self.fy_abs)**2,t-1e-9)
                self._getCarrierDensity=_getCarrierDensity

        elif self.direction == "edge":
            self.x_step=self.h_step
            self.x_char=self.h_char
            self.y_step=self.z_step=self.r_step
            self.y_char=self.z_char=self.r_char

            absorb_depth=self.lx*self.fx_rel
            def _getCarrierDensity(x,y,z,t):
                return self.getCarrierDensity(x-self.fx_abs,absorb_depth,(y-self.fy_abs)**2+(z-self.fz_abs)**2,t-1e-9)
            self._getCarrierDensity=_getCarrierDensity
        else:
            raise NameError(self.direction)

    def getCarrierDensity(self,h,depth,r2,t):
        #return the carrier density of a given point
        #referring to the vertical and horizontal distance from the focus 
        widthSquared=(self.widthBeamWaist**2)*(1+(h/self.l_Rayleigh)**2)
        intensity = ((self.power)/self.tau)\
                    *(4*np.log(2)**0.5/(np.pi**1.5*widthSquared*1e-12))\
                    *np.exp((-2*r2/(widthSquared)))\
                    *np.exp(-4*np.log(2)*t**2/self.tau**2)

        if self.tech=="SPA":
            e0 = 1.60217733e-19
            return self.alpha*intensity*np.exp(-self.alpha*(h+depth)*1e-6)/(3.6*e0)
            
        elif self.tech=="TPA":
            h_Planck = 6.626*1e-34
            speedofLight = 2.998*1e8
            return self.beta_2*self.wavelength*1e-6*intensity**2/(2*h_Planck*speedofLight)
