"""This file contains functions and classes which can be classified as utilitie
functions for a more general purpose. Furthermore, these functions are for
python analysis of ALIBAVA files."""

import logging
import logging.config
import os
import struct
import sys
from pydoc import locate
import numpy as np
import h5py
import yaml
from tqdm import tqdm
from six.moves import cPickle as pickle  # for performance
import matplotlib.pyplot as plt
from matplotlib.backends.backend_pdf import PdfPages
import scipy.integrate as integrate
import json
from copy import deepcopy

def read_meas_files(cfg):
    """Reads cfg file, returns lists of files and compares their length"""
    ped_files = cfg["Pedestal_file"]
    if cfg["use_charge_cal"]:
        cal_files = cfg["Charge_scan"]
    else:
        cal_files = cfg["Delay_scan"]
    run_files = cfg["Measurement_file"]

    # Case selection if files are lists or simply one file as paths
    if all(isinstance(i, list) for i in [ped_files, run_files, cal_files]):
        if not len(ped_files) == len(run_files) or \
                not len(cal_files) == len(run_files):
            raise ValueError("Number of pedestal, calibration and measurement files"
                             " does not match...")
    # Case where only a path string is passed
    elif all(isinstance(i, str) for i in [ped_files, run_files, cal_files]):
        ped_files = [ped_files]
        cal_files = [cal_files]
        run_files = [run_files]

    # Case where only one pedestal and cal file but several run files, use the same pedestal and cal for all runs
    elif (isinstance(run_files, list) and isinstance(ped_files, str) and isinstance(cal_files, str)):
        ped_files = [ped_files for i in run_files]
        cal_files = [cal_files for i in run_files]


    else:
        raise ValueError("Pedestal, calibration and measurement files must "
                         "either be passed as strings or as "
                         "lists of same length")

    return zip(ped_files, cal_files, run_files)

def init_logger(path='logger.yml', default_level=logging.INFO, env_key='LOG_CFG'):
    """Loads a logger file and initiates logger"""
    value = os.getenv(env_key, None)
    if value:
        path = value
    if os.path.exists(os.path.normpath(path)):
        with open(path, 'rt') as f:
            config = yaml.safe_load(f.read())
        logging.config.dictConfig(config)
    else:
        logging.basicConfig(level=default_level)

LOG = logging.getLogger("utilities")

def load_plugins(valid_plugins):
    """Load additional analysis functions. File names are expected to be all
    lower case while class names are capitalized.
    Args:
        - valid_plugins (str): class names"""
    position_flag = True if 'PositionResolution' in valid_plugins else False
    print(position_flag,valid_plugins)

    all_plugins = {}
    all_analysis_files = os.listdir("python/alibava/analysis_classes/")
    if position_flag:
        all_analysis_files.remove('PositionResolution.py')
        all_analysis_files.append('PositionResolution.py')
        pass
    print("test xmm =============",all_analysis_files)
    if valid_plugins:
        for file in all_analysis_files:
            for plugin in valid_plugins:
                if os.path.splitext(file)[0].lower() == plugin.lower():
                    all_plugins[plugin] = \
                        locate("analysis_classes." + plugin + "." + plugin)
    return all_plugins

def create_dictionary(abs_filepath):
    """Creates a dictionary with all values written in the file using yaml"""
    with open(abs_filepath, "r") as yfile:
        dic = yaml.safe_load(yfile)
    return dic

def import_h5(path):
    """
    This functions imports hdf5 files generated by ALIBAVA.
    If you pass several pathes, then you get list of objects back, containing
    the data respectively
    :param pathes: pathes to the datafiles which should be imported
    :return: list
    """
    # First check if path exists and if so import hdf5 file
    try:
        if not os.path.exists(os.path.normpath(path)):
            raise Exception('The path {!s} does not exist.'.format(path))
        return h5py.File(os.path.normpath(path), 'r')
    except OSError as err:
        LOG.error("Encountered an OSError: %s", str(err))
        return False

def save_all_plots(name, folder, figs=None, dpi=200):
    """
    This function saves all generated plots to a specific folder with the defined name in one pdf
    :param name: Name of output
    :param folder: Output folder
    :param figs: Figures which you want to save to one pdf (leaf empty for all plots) (list)
    :param dpi: image dpi
    :return: None
    """
    try:
        pp = PdfPages(os.path.join(os.path.normpath(folder), name + ".pdf"))
    except PermissionError:
        raise PermissionError(
            "While overwriting the file {!s} a permission error occured, "
            "please close file if opened!".format(name + ".pdf"))
    if figs is None:
        figs = [plt.figure(n) for n in plt.get_fignums()]

    for fig in tqdm(figs, desc="Saving plots"):
        fig.set_figheight(9)
        fig.set_figwidth(16)
        fig.savefig(pp, format='pdf')
    pp.close()

class Bdata:
    """Creates an object which can handle numpy arrays. By passing lables you
    can get the columns of the multidimensional array. Its like a pandas array
    but with way less overhead.
    If you store a Bdata object you can get columns by accessing it via Bdata['label']
    Not passing an argument results in """

    def __init__(self, data = np.array([]), labels = None):

        # Has nothing to do here, this is a Data type not a typical class

        self.data = data
        self.labels = labels
        self.log = LOG

        if len(self.data) != len(self.labels):
            self.log.warning("Data missmatch!")

    def __getitem__(self, arg=None):
        # COMMENT: else returns 'None' is correct?
        if arg:
            return self.get(arg)

    def __repr__(self):
        return repr(self.data)

    def keys(self):
        """Returns the keys list"""
        return self.labels

    def get(self, label):
        """DOC of function"""
        return self.data[:,self.labels.index(label)]
    
def handle_sub_plots(fig, index=111):
    """Adds subplot to existing figure or creates a new one if fig
    non-existing"""
    if fig is None:
        fig = plt.figure()
        plot = fig.add_subplot(111)
    else:
        plot = fig.add_subplot(index)
    return plot